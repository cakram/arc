* use PG_GLOBAL flag for anything in the kernel addresss space and check all
  the TLB flushing is done properly

* look at how caching should work for memory-mapped I/O devices like the local
  APIC and I/O APIC

* the PMM should be reworked to also support contiguous regions of memory

* check if in*_p() and out*_p() are still required

* split features into local CPU features and features that all CPUs share

* elf64 size checks to check we don't read outside the bounds of the elf64 file

* free module pmm frames when they are loaded

* don't use PIT channel 2 for pit_mdelay(), using the KBC to check if the
  countdown has finished seems to be unreliable on modern hardware
  (note: this issue actually seems to be the APs not responding to the init
  sequence and seems to happen in Linux as well on this hardware sometimes?)

* use enums in more places (e.g. heap node state)

* add idle process and threads (one per cpu)

* use a more efficient user-space heap structure (red black tree?)

* consider interupt masking more in relation to locks (e.g. current solution
  won't work for exceptions as they aren't masked, and locks which don't mask
  interrupts should be added to improve performance where it isn't required.)

* make TLB flushes more efficient e.g. by batching together more VMM operations

* change tty_* -> trace_*, then make it so it can be backed by tty or uart,
  will be useful for debugging to see the whole log rather than just what fits
  into the 80x25 vga console (add trace=tty,uart,e9|off param to cmdline)

* consider issue that proc and thread in cpu_t might not be consistent - is
  this going to cause problems? do we need any locking there also?

* make uheap_alloc() always zero memory it gives out, for security reasons. or
  should this be done by its callers?

* switch from NASM to GNU AS?

* re-structure some of the headers (mainly mm and proc folders, esp. common
  stuff, also split arc/types.h?)

* x2APIC support in MADT parsing code

* make it so cmdline doesn't depend on a memory allocator, this way it can be
  used early enough to select the trace output(s)

* check which trigger/level should be use for NMIs by default, and if we need
  to put this in the LVT for local NMIs

* instead of external locking dlmalloc, embed our own spinlock code inside it,
  this means it can do stuff like per-mspace locks

* dlmalloc seems to be infinite looping for large allocations

* I/O NMI code should route to NMI, and not to FAULT2, see ioapic_route_nmi()

* forget about NMIs? they make everything messy

* load kernel at 2MB instead, to get rid of the +1MB offset. also ensure pmm
  won't touch _any_ space mapped into the kernel's virtual memory (so round
  up to the next 2mb boundary when reserving kernel's physical memory)

* should IPI_ROUTE still exist?

* remove support for MGA tty, all amd64 PCs should support CGA at least
